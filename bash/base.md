## {} & ()                                                                                                                              
```
# {}1.扩展
# 一个命令可能会对大括号中的以逗号分割的文件列表起作用. (通配(globbing))将对大括号中的文件名做扩展
# 在大括号中, 不允许有空白, 除非这个空白被引用或转义.
$ cp 1.{txt, bak}
# cp: cannot stat `1.{txt,': No such file or directory
a=123
c=${a/12/BB} # 将"12"替换成"BB"
echo $c # BB3
$ ls
# 1.txt 1.bak
a=123
(a=321)
echo $a # 123
# 在圆括号中a变量, 更像是一个局部变量
# 括号中的命令将会新开一个子shell顺序执行，所以括号中的变量不能够被脚本余下的部分使用。
# {}2.代码块，又被称为内部组，这个结构事实上创建了一个匿名函数 。
# 与小括号中的命令不同，大括号内的命令不会新开一个子shell运行，即脚本余下部分仍可使用括号内变量。
# 括号内的命令间用分号隔开，最后一个也必须有分号。{}的第一个命令和左括号之间必须要有一个空格。
{ a=321; }
echo $a  # 321

```
## if
### 字符串比较

- str1 = str2，字符串1匹配字符串2
- str1 != str2，字符串1不匹配字符串2
- str1 > str2，字符串1大于字符串2
- str1 < str2，字符串1小于字符串2
- -n str，字符串不为null，长度大于零
- -z str，字符串为null，长度为零;当-n使用在中括号中进行条件测试的时候, 必须要把字符串用双引号引用起

```
if [ -n "$xyz" ]; then # false
if [ -n $xyz ]; then   # true
if [ $xyz ]; then      # false
```

### 文件属性比较

- -a   file ：file 存在
- -d file ：file存在并是一个目录
- -e file ：file 存在，同- a
- -f file ：file 存在并且是一个常规的文件（不是目录或者其他特殊类型文件）
- -r file ：有读的权限
- -s file ：文件存在且不为空
- -w file ：有写的权限
- -x file ：有执行的权限，或者对于目录有search的权限
- -N file ：在上次读取后，文件有改动
- -O file ：own所属的文件
- -G file ：group所属的文件
- file1 -nt file2 ：file1 比 file2 更新，以最后更新时间为准
- file1 -ot file2 ：file1 比 file2 更旧 ，以最后更新时间为准
- file1 -ef file2 ：文件file1和文件file2是相同文件的硬链接

### 整数比较

- -lt，小于
- -le，小于等于
- -eq，等于
- -ge，大于等于
- -gt，大于
- -ne，不等于

```
c=1
d=0
#if (( $c < $d ))
## if [ $c < $d ] #-----> 0: No such file or directory
#if [ $c \< $d ]
#if [[ $c < $d ]]
if [ $c -lt $d ]
then
  echo 'c < d'
else
  echo 'c >= d'
fi
```
### if [ ...  === if test ...
使用[[ ... ]]条件判断结构, 而不是[ ... ], 能够防止脚本中的许多逻辑错误. 比如,
&&, ||, <, 和> 操作符能够正常存在于[[ ]]条件判断结构中, 但是如果出现在[ ]结构中
的话, 会报错.
```
VAR1="file1"
VAR2="file2"
VAR3="file3"

if [ -f $VAR1 ] && [ -f $VAR2 ] && [ -f $VAR3 ]
then  ....

if [[ -f $VAR1 && -f $VAR2 && -f $VAR3 ]]
then  ....

if [ -f $VAR1 -a -f $VAR2 -a -f $VAR3 ]
then  ....

if test -f $VAR1 -a -f $VAR2 -a ! -f $VAR3; then

if test -f $VAR1 && test -f $VAR2 && test ! -f $VAR3; then
```

## 位置参数-------从命令行传递到脚本的参数

- $# ----传递给程序的总的参数数目
- $? ----上一个代码或者shell程序在shell中退出的情况，如果正常退出则返回0，反之为非0值。
- $* ----传递给程序的所有参数组成的字符串。
- $0 ----当前程序的名称
- $n ----表示第几个参数，$1 表示第一个参数，$2 表示第二个参数 ...
- $@ ----以"参数1" "参数2" ... 形式保存所有参数
- $$ ----本程序的(进程ID号)PID
- $! ----上一个命令的PID
- $_ ----保存之前执行的命令的最后一个参数

$0就是脚本文件自身的名字, $1 是第一个参数, $2是第二个参数, $3是第三个参数, 然后是第四个. [1] $9之后的位置参数就必须用大括号括起来了, 比>如, ${10}, ${11}, ${12}.
两个比较特殊的变量$*和$@ 表示所有的位置参数
